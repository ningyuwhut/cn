---
layout: post 
title: java final 关键字
categories:
- java
---

###final数据

final修饰基本类型时,该变量成为常量,当修饰对象引用时,final使引用不变.一旦引用被初始化为指向一个对象,就不能再把它改为指向另外一个对象,然而,该对象自身却是可以修改的.

还有一种空白final,就是被声明为final但是又没有给定初值的域.对于空白final,必须在域的定义处或者每个构造器中对final进行赋值.

###final参数

final参数表示在方法中无法更改参数引用使其指向其他对象.

###final方法

使用finla方法有两个原因:

1. 锁定方法,防止继承类重写.
2.效率,但是现在这种方法已经不再被提倡.

所以只有想禁止覆盖时才将方法设置为final的.

###final 类

当类被定义为final时,表明该类不可继承

##接口

先说抽象类

抽象类是不能实例化的类,使用abstract声明一个类为抽象类.
抽象类可以包含也可以不包含抽象方法.
所谓抽象方法就是只有声明而没有定义的方法.

如果一个类继承了抽象类,那么它就必须实现抽象类中的所有抽象方法

java中的抽象类和C++中的抽象类可以说是对应的,抽象方法和纯虚函数也是对应的.

###接口

接口只有方法声明而没有定义,使用interface声明.接口中可以包含成员变量,默认是static final类型.

接口中的方法默认是public的,

其他类通过implements关键字实现某个接口,为了遵守接口的协议,继承类必须实现接口中的所有方法.

通过继承多个接口,我们可以实现多重继承.
当继承一个具体类和多个接口时,这个具体类必须放在前面,否则编译器会报错.

使用接口的核心原因:

1. 可以向上转型为多个基类型
2. 与抽象基类相同,可以防止客户端程序员创建该类的对象,并确保这仅仅是一个接口.

那么何时使用接口,何时使用抽象类?

如果创建不带任何方法定义和成员变量的基类,那么就应该选择接口.
事实上,如果知道某事物应该称为一个基类,那么第一选择应该是让它成为一个接口.

接口也可以继承接口

    interface Monster{
	void menace();
    }
    interface DangerousMonster extends Monster{
	void destroy();
    }
    interface Lethal{
	void kill();
    }
    interface Vampire extends DangerousMonster, Lethal{
	void drinkBlood();
    }

在Vampire中的语法仅适用于接口继承.

组合接口时要避免名字冲突

    interface I1{ void f(); };
    interface I2{ int f(); };

    interface I3 extends I1, I3{}//错误!!

###初始化与清理

和C++一样,Java中也不允许只有返回类型不同的方法重载
和C++一样,Java中如果自定义了constructor,编译器也不再合成一个默认版本

static方法就是没有this的方法.在static方法内部不能调用非静态方法,反过来可以.

Java的垃圾回收器只回收由new分配的内存,对于某些"特殊"内存(如何特殊我也不知道....大概是文件或者数据库连接之类的资源),我们需要使用finalize方法.

在C++中,对象一定会被销毁;java中的对象并非总是被垃圾回收,即

1. 对象可能不被垃圾回收
2. 垃圾回收不等同于析构
3. 垃圾回收只和内存相关

对finalize的需求主要存在于使用非java方式创建对象,比如通过java调用其他语言的代码(本地方法),比如调用C,而C中使用malloc分配的内存没有使用free释放,那么有可能内存泄露,finalzied就可以用本地方法调用free释放掉内存.

总之,不要过多地使用finalize.




引用技术是一种简单却慢速的垃圾回收技术,而且不能处理循环引用情形.因此几乎没有任何一种Java虚拟机使用这种方法.

垃圾回收是很重要的知识点,编程思想讲的比较少,先跳过


###初始化

类的基本类型成员都会得到初始值.

在类里定义一个对象引用时,如果没有将其初始化,该引用会获得一个null作为初始值.

可以在定义类时就对数据成员进行初始化

    public class InitialValues{
	boolean bool = true;
	in i = 99;

	Depth d = new Depth();//定义省略

	int j = f();
	int f() { return 11; };

    }

也可以使用构造器初始化,但是remember: **无法阻止自动初始化的进行,它将在构造器被调用之前就发生.**

    public class Counter{
	int i;
	Counter() { i = 7;}
    }

i会先初始化为0, 然后被赋值为7.这对所有今本类型和对象引用都成立,包括在定义时指定初始值.

在类定义中,成员定义的先后顺序决定了初始化的顺序,即使成员定义在方法之后.

变量初始化会先于方法得到调用

静态对象的初始化会首先进行,然后是非静态对象,最后是构造器

总结一下对象的创建过程,假设有个名为Dog的类:

1.即使没有显示地使用static关键字,构造器实际上也是静态方法.隐藏,当首次创建Dog类型的对象时,或者Dog类的静态方法/静态域首次被访问时,Java解释器必须查找类路径,以定位Dog.class文件

2.然后载入Dog.class,有关静态初始化的所有动作都会执行.因此,静态初始化只在Class对象首次加载的时候进行一次.

3.当用new Dog()创建对象的时候,首先将在堆上为Dog对象分配足够的存储空间.

4.该空间清零,这就自动地将Dog对象中的所有基本数据类型设置为默认值,而引用则被设置为null.

5.执行所有出现与成员定义出的初始化动作

6.执行构造器.
 

当类中包含静态块(静态子句)时,与其他静态初始化动作一样,这段代码仅执行一次:

> 当首次生成这个类的一个对象时,或者首次访问属于这个类的静态数据成员时

也就是说如果不生成对象或者不访问类的静态成员时,静态成员的初始化和静态子句都不会执行.

    class Cup{
	Cup( int marker ){
	    print("Cup("+marker + ")");
	}
	void f( int marker ){
	    print("f("+marker+")");
	}
    }

    class Cups{
	static Cup cup1;
	static Cup cup2;
	static{
	    cup1 = new Cup(1);
	    cup2 = new Cup(2);
	}
	Cups(){
	    print("Cups()");
	}
    }

    public class ExplicitStatic{
	public static void main(String[] args ){
	    Cups.cup1.f(99);
	}
    }

输出如下:

    Cup(1);
    Cup(2);
    f(99);

还有非静态实例初始化,它们也是先于构造器执行

创建基本类型的数组时,其元素值会自动初始化为空值;对于非基本类型的数组,在使用new分配空间后,它还只是一个引用数组,只有通过创建新的对象并把对象赋值给引用,初始化才算结束.如果不创建对象,那么数组元素仍为空.


多态又叫动态绑定,后期绑定或运行时绑定.

Java中除了static方法和final方法之外,其他所有的方法都是后期绑定.

只有普通方法可以发生多态,数据成员和静态方法都不会发生多态.
